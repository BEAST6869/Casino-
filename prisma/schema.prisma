generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// Models adapted for MongoDB (ObjectId fields).

model User {
  id          String @id @default(auto()) @map("_id") @db.ObjectId
  discordId   String @unique
  username    String

  wallet      Wallet?
  bank        Bank?

  creditScore Int @default(500)
  
  // User preferences
  profileTheme String @default("cyberpunk") 

  bets        Bet[]
  inventory   Inventory[] // Relation to Inventory items
  
  lastDaily   DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Leveling
  xp          Int      @default(0)
  level       Int      @default(0)

  // Ban System
  isBanned    Boolean  @default(false)

  loans       Loan[]
  investments Investment[]
  listings    MarketListing[]
}

model Wallet {
  id           String        @id @default(auto()) @map("_id") @db.ObjectId
  user         User          @relation(fields: [userId], references: [id])
  userId       String        @unique @db.ObjectId
  balance      Int           @default(0)
  transactions Transaction[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model Transaction {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  wallet    Wallet   @relation(fields: [walletId], references: [id])
  walletId  String   @db.ObjectId
  amount    Int
  type      String   // e.g.: income, admin_add, wallet_to_bank, bank_to_wallet, bet, payout, transfer_sent, transfer_recv
  meta      Json?
  isEarned  Boolean? @default(false)
  createdAt DateTime @default(now())
}



model Bet {
  id        String      @id @default(auto()) @map("_id") @db.ObjectId
  user      User        @relation(fields: [userId], references: [id])
  userId    String      @db.ObjectId
  gameId    String
  amount    Int
  choice    String?
  result    String?
  payout    Int?
  createdAt DateTime    @default(now())
}

model RoleIncome {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  guildId   String
  roleId    String
  amount    Int 
  cooldown  Int       @default(86400) // Default 24 hours
  createdAt DateTime  @default(now())

  claims    RoleIncomeClaim[]
  
  @@unique([guildId, roleId])
}

model RoleIncomeClaim {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  userId       String   @db.ObjectId
  roleIncomeId String   @db.ObjectId
  claimedAt    DateTime @default(now())
  
  roleIncome   RoleIncome @relation(fields: [roleIncomeId], references: [id])

  @@unique([userId, roleIncomeId]) // One claim record per user/role pair (we update claimedAt)
}

model Job {
  id          String @id @default(auto()) @map("_id") @db.ObjectId
  guildId     String
  key         String @unique
  name        String
  minPay      Int
  maxPay      Int
  successRate Float?
  cooldown    Int
}

model ShopItem {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  guildId      String
  name         String
  description  String   @default("No description")
  price        Int
  stock        Int      @default(-1) // -1 = unlimited
  roleId       String?  
  
  // Relations
  inventory    Inventory[]
  marketListings MarketListing[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

// FIX: Added 'user' relation field to match 'inventory' in User model
model Inventory {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  guildId     String
  
  // This relation connects back to the User model
  user        User     @relation(fields: [userId], references: [id])
  userId      String   @db.ObjectId
  
  shopItem    ShopItem @relation(fields: [shopItemId], references: [id], onDelete: Cascade)
  shopItemId  String   @db.ObjectId
  
  amount      Int      @default(1)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, shopItemId])
}

model Audit {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  guildId   String?
  userId    String?
  type      String 
  meta      Json?
  createdAt DateTime @default(now())
}

model Bank {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @unique @db.ObjectId
  balance   Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model IncomeConfig {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  guildId        String
  commandKey     String   
  minPay         Int
  maxPay         Int
  cooldown       Int      
  successPct     Int?     @default(100)
  failPenaltyPct Int?     @default(50)
  createdAt      DateTime @default(now())

  @@unique([guildId, commandKey])
}



model Loan {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  user           User     @relation(fields: [userId], references: [id])
  userId         String   @db.ObjectId
  amount         Int
  totalRepayment Int      // Principal + Interest
  interestRate   Int      // Stored as percentage (e.g., 5 for 5%)
  dueDate        DateTime
  status         String   // ACTIVE, PAID, DEFAULTED
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Investment {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  user         User     @relation(fields: [userId], references: [id])
  userId       String   @db.ObjectId
  type         String   // FD, RD
  amount       Int
  interestRate Int      // Stored as percentage
  startDate    DateTime @default(now())
  maturityDate DateTime
  status       String   // ACTIVE, COMPLETED, WITHDRAWN
  
  // For RDs, we might need to track monthly contributions, but keeping it simple for now (lump sum for simplified RD or just recurring deposits logic handled in service)
  // Re-reading requirements: "keeping money in FDs RDs etc with interest rates"
  // Assuming standard fixed deposit behavior.
  
  updatedAt    DateTime @updatedAt
}

model GuildConfig {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  guildId       String   @unique
  currencyName  String   @default("Coins")
  currencyEmoji String   @default("ðŸª™")
  startMoney    Int      @default(1000)
  transferTax   Int      @default(0)
  incomeTax     Int      @default(0)
  bankLimit     Int?     @default(1000000)
  walletLimit   Int?     @default(1000000)
  interestRate  Int      @default(0) // Logic for savings account interest
  prefix        String   @default("!")
  
  // Configs
  robSuccessPct  Int      @default(60)
  robFinePct     Int      @default(20)
  robCooldown    Int      @default(300)
  robImmuneRoles String[] @default([])
  
  minBet         Int      @default(100)

  // Banking System Configs
  loanInterestRate Int      @default(5)
  fdInterestRate   Int      @default(10)
  rdInterestRate   Int      @default(8)
  loanMaxAmount    Int?     // If null, dynamic based on credit score

  marketTax        Int      @default(5) // % tax on black market sales

  creditConfig     Json?    @default("[]") // Array of { minScore: number, maxLoan: number, maxDays: number }
  creditScoreReward Int     @default(10)   // Score gained on on-time repayment
  creditScorePenalty Int    @default(20)   // Score lost on late repayment
  maxCreditScore    Int      @default(2000)
  maxActiveLoans    Int      @default(1)    // Max simultaneous active loans per user
  minCreditScore    Int      @default(0)    // Minimum credit score floor

  gameCooldowns    Json?    @default("{}") // e.g. {"slots": 30, "bj": 10}

  logChannelId     String?  // Channel ID for audit logs
  enableAskCommand Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MarketListing {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  guildId     String
  seller      User     @relation(fields: [sellerId], references: [id])
  sellerId    String   @db.ObjectId
  
  // Snapshotted item details (in case ShopItem changes or deleted)
  // But ideally we link to ShopItem to show image/details dynamically.
  // Converting inventory item to listing.
  shopItem    ShopItem @relation(fields: [shopItemId], references: [id])
  shopItemId  String   @db.ObjectId
  
  amount      Int
  totalPrice  Int      // Price for the whole batch
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}