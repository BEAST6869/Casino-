import prisma from "../utils/prisma";import { getGuildConfig } from "./guildConfigService";export async function placeBetWithTransaction(  userId: string,  walletId: string,  gameId: string,  amount: number,  choice: string,  didWin: boolean,  payout: number,  guildId: string): Promise<number> {  const config = await getGuildConfig(guildId);  const currentWallet = await prisma.wallet.findUnique({ where: { id: walletId } });  if (!currentWallet) throw new Error("Wallet not found");  let actualPayout = payout;  if (didWin && config.walletLimit) {    const projectedBalance = currentWallet.balance - amount + payout;    if (projectedBalance > config.walletLimit) {      const allowedPayout = config.walletLimit - (currentWallet.balance - amount);      actualPayout = Math.max(0, allowedPayout);     }  }  const netChange = actualPayout - amount;  await prisma.$transaction(async (tx) => {    await tx.bet.create({      data: {        userId,        gameId,        amount,        choice,        result: didWin ? "win" : "lose",        payout: actualPayout      }    });    await tx.transaction.create({      data: {        walletId,        amount: netChange,        type: didWin ? "payout" : "bet",        meta: { choice, payout: actualPayout, originalPayout: payout, didWin }      }    });    await tx.wallet.update({      where: { id: walletId },      data: { balance: { increment: netChange } }    });  });  return actualPayout;}export async function placeBetFallback(  walletId: string,  userId: string,  gameId: string,  amount: number,  choice: string,  didWin: boolean,  payout: number,  guildId: string): Promise<number> {  const config = await getGuildConfig(guildId);  const currentWallet = await prisma.wallet.findUnique({ where: { id: walletId } });  if (!currentWallet) throw new Error("Wallet not found");  let actualPayout = payout;  if (didWin && config.walletLimit) {    const projected = currentWallet.balance - amount + payout;    if (projected > config.walletLimit) {      actualPayout = Math.max(0, config.walletLimit - (currentWallet.balance - amount));    }  }  const res = await prisma.wallet.updateMany({    where: { id: walletId, balance: { gte: amount } },    data: { balance: { decrement: amount } }  });  if (res.count === 0) throw new Error("Insufficient funds during betting stage");  await prisma.bet.create({    data: { userId, gameId, amount, choice, result: didWin ? "win" : "lose", payout: actualPayout }  });  await prisma.transaction.create({    data: {      walletId,      amount: didWin ? (actualPayout - amount) : -amount,       type: didWin ? "payout" : "bet",      meta: { choice, payout: actualPayout, didWin }    }  });  if (didWin) {    await prisma.wallet.update({ where: { id: walletId }, data: { balance: { increment: actualPayout } } });  }  return actualPayout;}