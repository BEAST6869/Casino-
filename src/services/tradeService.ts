import prisma from "../utils/prisma";export type TradeResult = {    success: boolean;    item: string;    amount: number;    price: number;    buyerId: string;    sellerId: string;};export async function executeTrade(    guildId: string,    sellerDiscordId: string,    buyerDiscordId: string,    itemId: string,    quantity: number,    price: number): Promise<TradeResult> {    if (quantity <= 0) throw new Error("Quantity must be positive.");    if (price < 0) throw new Error("Price cannot be negative.");    return prisma.$transaction(async (tx) => {        const seller = await tx.user.findUnique({            where: { discordId_guildId: { discordId: sellerDiscordId, guildId } },            include: { wallet: true }        });        const buyer = await tx.user.findUnique({            where: { discordId_guildId: { discordId: buyerDiscordId, guildId } },            include: { wallet: true }        });        if (!seller || !buyer) throw new Error("User not found.");        if (!seller.wallet) throw new Error("Seller has no wallet.");        if (!buyer.wallet) throw new Error("Buyer has no wallet.");         const inventory = await tx.inventory.findUnique({            where: {                userId_shopItemId: {                    userId: seller.id,                    shopItemId: itemId                }            },            include: { shopItem: true }        });        if (!inventory || inventory.amount < quantity) {            throw new Error("You do not have enough of this item to trade.");        }        if (price > 0 && buyer.wallet.balance < price) {            throw new Error(`Buyer doesn't have enough money (${price} required).`);        }        if (price > 0) {            await tx.wallet.update({                where: { id: buyer.wallet.id },                data: { balance: { decrement: price } }            });            await tx.wallet.update({                where: { id: seller.wallet.id },                data: { balance: { increment: price } }            });            await tx.transaction.create({                data: {                    walletId: buyer.wallet.id,                    amount: -price,                    type: "trade_payment",                    meta: { to: sellerDiscordId, item: inventory.shopItem.name },                    isEarned: false                }            });        }        if (inventory.amount === quantity) {            await tx.inventory.delete({ where: { id: inventory.id } });        } else {            await tx.inventory.update({                where: { id: inventory.id },                data: { amount: { decrement: quantity } }            });        }        await tx.inventory.upsert({            where: {                userId_shopItemId: {                    userId: buyer.id,                    shopItemId: itemId                }            },            create: {                guildId: inventory.guildId,                userId: buyer.id,                shopItemId: itemId,                amount: quantity            },            update: {                amount: { increment: quantity }            }        });        return {            success: true,            item: inventory.shopItem.name,            amount: quantity,            price,            buyerId: buyerDiscordId,            sellerId: sellerDiscordId        };    });}