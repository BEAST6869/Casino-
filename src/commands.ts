import { Message } from "discord.js";import prisma from "./utils/prisma";export async function handleMessage(message: Message) {  const [cmd, ...args] = message.content.slice(1).trim().split(/\s+/);  const discordId = message.author.id;  switch (cmd.toLowerCase()) {    case "balance":      return cmdBalance(message, discordId);    case "deposit":      return cmdDeposit(message, discordId, args);    case "bet":      return cmdBet(message, discordId, args);    default:      return message.reply("Unknown command. Try `!balance`, `!deposit <amount>`, `!bet <amount> <choice>`");  }}async function ensureUserAndWallet(discordId: string, guildId: string, username: string) {  const user = await prisma.user.upsert({    where: { discordId_guildId: { discordId, guildId } },    update: { username },    create: {      discordId,      guildId,      username,      wallet: { create: { balance: 1000 } }     },    include: { wallet: true }  });  return user;}async function cmdBalance(message: Message, discordId: string) {  const user = await ensureUserAndWallet(discordId, message.guildId!, message.author.tag);  const balance = user.wallet?.balance ?? 0;  await message.reply(`Your balance: ${balance}`);}async function cmdDeposit(message: Message, discordId: string, args: string[]) {  const amount = Math.floor(Number(args[0] || 0));  if (!amount || amount <= 0) { await message.reply("Enter a valid deposit amount."); return; }  const user = await ensureUserAndWallet(discordId, message.guildId!, message.author.tag);  const walletId = user.wallet!.id;  await prisma.$transaction([    prisma.transaction.create({ data: { walletId, amount, type: "deposit", meta: { via: "manual" } } }),    prisma.wallet.update({ where: { id: walletId }, data: { balance: { increment: amount } } })  ]);  const refreshed = await prisma.wallet.findUnique({ where: { id: walletId } });  await message.reply(`Deposited ${amount}. New balance: ${refreshed?.balance ?? 0}`);}async function cmdBet(message: Message, discordId: string, args: string[]) {  const amount = Math.floor(Number(args[0] || 0));  const choice = args[1] ?? "default";  if (!amount || amount <= 0) { await message.reply("Enter a valid bet amount."); return; }  const user = await ensureUserAndWallet(discordId, message.guildId!, message.author.tag);  const wallet = user.wallet!;  if (!wallet) { await message.reply("Wallet not found. Try again."); return; }  if (wallet.balance < amount) { await message.reply("Insufficient funds."); return; }  const didWin = Math.random() < 0.5;  const payout = didWin ? amount * 2 : 0;  const netChange = payout - amount;   try {    await betWithTransaction(user.id, wallet.id, amount, choice, didWin, payout, netChange);  } catch (e) {    console.warn("Transaction bet failed, attempting fallback:", (e as Error).message);    try {      await betFallbackAtomic(wallet.id, user.id, amount, choice, didWin, payout, netChange);    } catch (err) {      console.error("Fallback bet failed:", err);      await message.reply("Bet failed due to internal error.");      return;    }  }  const newWallet = await prisma.wallet.findUnique({ where: { id: wallet.id } });  const newBal = newWallet?.balance ?? 0;  if (didWin) {    await message.reply(`You won! Payout ${payout}. New balance: ${newBal}`);  } else {    await message.reply(`You lost ${amount}. New balance: ${newBal}`);  }}async function betWithTransaction(userId: string, walletId: string, amount: number, choice: string, didWin: boolean, payout: number, netChange: number) {  await prisma.$transaction(async (tx) => {    await tx.bet.create({      data: {        userId,        gameId: "roulette_id_placeholder",        amount,        choice,        result: didWin ? "win" : "lose",        payout      }    });    await tx.transaction.create({      data: {        walletId,        amount: netChange,        type: didWin ? "payout" : "bet",        meta: { choice, payout, didWin }      }    });    await tx.wallet.update({      where: { id: walletId },      data: { balance: { increment: netChange } }    });  });}async function betFallbackAtomic(walletId: string, userId: string, amount: number, choice: string, didWin: boolean, payout: number, netChange: number) {  const res = await prisma.wallet.updateMany({    where: { id: walletId, balance: { gte: amount } },    data: { balance: { decrement: amount } }   });  if (res.count === 0) {    throw new Error("Insufficient funds at update stage");  }  await prisma.bet.create({    data: {      userId,      gameId: "roulette_id_placeholder",      amount,      choice,      result: didWin ? "win" : "lose",      payout    }  });  await prisma.transaction.create({    data: {      walletId,      amount: didWin ? (payout) - amount : -amount,       type: didWin ? "payout" : "bet",      meta: { choice, payout, didWin }    }  });  if (didWin) {    await prisma.wallet.update({ where: { id: walletId }, data: { balance: { increment: payout } } });  }}